<script>
  /* ============================================
     전역 상태
     ============================================ */
  const AppState = {
    currentUser: null, // { name, number, token, role }
    settings: null,
    isTeacher: false,
    isPersonalMode: false, // 개인 모드 여부
    currentRoute: null,
  };

  /* ============================================
     시스템 모드 상수
     ============================================ */
  const SYSTEM_MODES = {
    CLASSROOM: "classroom", // 학급 모드 (교사 + 학생)
    PERSONAL: "personal", // 개인 모드 (로그인 없음)
  };

  /* ============================================
     API 호출 함수
     ============================================ */
  async function callApi(action, data = {}) {
    try {
      showLoading();

      // 교사 토큰 자동 주입 (세션 스토리지 또는 AppState에서)
      let token = null;
      try {
        token = sessionStorage.getItem("teacherToken");
      } catch (e) {
        /* ignore */
      }

      if (!token && AppState && AppState.teacherToken) {
        token = AppState.teacherToken;
      }

      const payload = { ...data };
      if (token) {
        payload.teacherToken = token;
      }

      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler((result) => {
            hideLoading();
            resolve(result);
          })
          .withFailureHandler((error) => {
            hideLoading();
            reject(error);
          })
          .callApi(action, payload);
      });
    } catch (error) {
      hideLoading();
      throw error;
    }
  }

  /* ============================================
     로딩 UI
     ============================================ */
  function showLoading(message = "잠시만 기다려주세요...") {
    const loader = document.getElementById("loading");
    if (loader) {
      loader.querySelector("p").textContent = message;
      loader.classList.remove("hidden");
    }
  }

  function hideLoading() {
    const loader = document.getElementById("loading");
    if (loader) {
      loader.classList.add("hidden");
    }
  }

  /* ============================================
     토스트 메시지
     ============================================ */
  function showToast(message, type = "info", duration = 3000) {
    const container = document.getElementById("toast-container");
    const toast = document.createElement("div");
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      <span>${getToastIcon(type)}</span>
      <span>${message}</span>
    `;
    container.appendChild(toast);

    setTimeout(() => {
      toast.style.opacity = "0";
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  function getToastIcon(type) {
    switch (type) {
      case "success":
        return "✅";
      case "error":
        return "❌";
      case "warning":
        return "⚠️";
      default:
        return "ℹ️";
    }
  }

  /* ============================================
     모달 (드래그 이동 + 크기 조절 지원)
     ============================================ */

  // 모달 버튼 액션 저장용
  let _modalButtonActions = [];

  // 모달 스택 (중첩 모달 지원)
  let _modalStack = [];

  // 모달 드래그 상태
  let _modalDragState = {
    isDragging: false,
    isResizing: false,
    startX: 0,
    startY: 0,
    startLeft: 0,
    startTop: 0,
    startWidth: 0,
    startHeight: 0,
  };

  function showModal(options) {
    const {
      title,
      content,
      buttons = [],
      onClose,
      extraActions = "",
      resizable = true,
    } = options;

    // 버튼 액션 저장
    _modalButtonActions = buttons.map((btn) => btn.action || null);

    const container = document.getElementById("modal-container");
    container.innerHTML = `
      <div class="modal-overlay" onclick="handleOverlayClick(event)">
        <div class="modal modal-draggable ${resizable ? "modal-resizable" : ""}"
             onclick="event.stopPropagation()"
             id="draggable-modal">
          <div class="modal-header" onmousedown="startModalDrag(event)" ontouchstart="startModalDrag(event)" style="cursor: move; touch-action: none;">
            <h3>${title}</h3>
            <div class="modal-header-actions">
              <button class="btn btn-icon btn-ghost modal-size-btn" onclick="toggleModalSize()" title="크기 전환">
                ⤢
              </button>
              <button class="btn btn-icon btn-ghost" onclick="closeModal()">✕</button>
            </div>
          </div>
          <div class="modal-body">
            ${content}
          </div>
          ${
            buttons.length > 0 || extraActions
              ? `
            <div class="modal-footer" style="display: flex; align-items: center; gap: 8px;">
              ${extraActions}
              <div style="flex: 1;"></div>
              ${buttons
                .map(
                  (btn, idx) => `
                <button class="btn ${btn.class || "btn-outline"}" onclick="${btn.action ? `handleModalButton(${idx})` : btn.onclick || "closeModal()"}">${btn.text}</button>
              `,
                )
                .join("")}
            </div>
          `
              : ""
          }
          ${resizable ? '<div class="modal-resize-handle" onmousedown="startModalResize(event)" ontouchstart="startModalResize(event)"></div>' : ""}
        </div>
      </div>
      <style>
        .modal-draggable {
          position: absolute;
          margin: 0;
          transition: none;
          display: flex;
          flex-direction: column;
        }

        .modal-resizable {
          min-width: 320px;
          min-height: 200px;
          max-width: 95vw;
          max-height: 90vh;
        }

        .modal-resizable .modal-body {
          flex: 1;
          overflow-y: auto;
          overflow-x: hidden;
          min-height: 0; /* flexbox 스크롤 버그 방지 */
        }

        .modal-header {
          user-select: none;
          flex-shrink: 0;
        }

        .modal-footer {
          flex-shrink: 0;
        }

        .modal-header-actions {
          display: flex;
          gap: 4px;
        }

        .modal-size-btn {
          font-size: 1.2rem;
        }

        .modal-resize-handle {
          position: absolute;
          bottom: 0;
          right: 0;
          width: 20px;
          height: 20px;
          cursor: nwse-resize;
          background: linear-gradient(135deg, transparent 50%, var(--border) 50%);
          border-radius: 0 0 12px 0;
          touch-action: none; /* 터치 디바이스 지원 */
        }

        .modal-resize-handle:hover {
          background: linear-gradient(135deg, transparent 50%, var(--primary) 50%);
        }

        .modal.maximized {
          top: 10px !important;
          left: 10px !important;
          width: calc(100vw - 20px) !important;
          height: calc(100vh - 20px) !important;
        }

        .modal.maximized .modal-resize-handle {
          display: none;
        }

        /* 터치 디바이스에서 더 큰 리사이즈 핸들 */
        @media (hover: none) and (pointer: coarse) {
          .modal-resize-handle {
            width: 30px;
            height: 30px;
          }
        }
      </style>
    `;

    // 모달 초기 위치 설정 (화면 중앙)
    const modal = document.getElementById("draggable-modal");
    if (modal) {
      setTimeout(() => {
        const rect = modal.getBoundingClientRect();
        modal.style.left = `${(window.innerWidth - rect.width) / 2}px`;
        modal.style.top = `${(window.innerHeight - rect.height) / 2}px`;
      }, 0);
    }

    if (onClose) {
      container._onClose = onClose;
    }
  }

  // 오버레이 클릭 처리 (드래그 중이 아닐 때만 닫기)
  function handleOverlayClick(event) {
    if (!_modalDragState.isDragging && !_modalDragState.isResizing) {
      if (event.target.classList.contains("modal-overlay")) {
        closeModal();
      }
    }
  }

  // 모달 드래그 시작 (마우스 + 터치 지원)
  function startModalDrag(event) {
    if (event.target.tagName === "BUTTON") return;

    const modal = document.getElementById("draggable-modal");
    if (!modal || modal.classList.contains("maximized")) return;

    // 터치 이벤트 처리
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;

    _modalDragState.isDragging = true;
    _modalDragState.startX = clientX;
    _modalDragState.startY = clientY;

    const rect = modal.getBoundingClientRect();
    _modalDragState.startLeft = rect.left;
    _modalDragState.startTop = rect.top;

    // 마우스 이벤트
    document.addEventListener("mousemove", handleModalDrag);
    document.addEventListener("mouseup", stopModalDrag);
    // 터치 이벤트
    document.addEventListener("touchmove", handleModalDrag, { passive: false });
    document.addEventListener("touchend", stopModalDrag);

    event.preventDefault();
  }

  // 모달 드래그 중 (마우스 + 터치 지원)
  function handleModalDrag(event) {
    if (!_modalDragState.isDragging) return;

    const modal = document.getElementById("draggable-modal");
    if (!modal) return;

    // 터치 이벤트 처리
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;

    const deltaX = clientX - _modalDragState.startX;
    const deltaY = clientY - _modalDragState.startY;

    let newLeft = _modalDragState.startLeft + deltaX;
    let newTop = _modalDragState.startTop + deltaY;

    // 화면 경계 체크
    const rect = modal.getBoundingClientRect();
    newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - rect.width));
    newTop = Math.max(0, Math.min(newTop, window.innerHeight - 50)); // 헤더는 항상 보이게

    modal.style.left = `${newLeft}px`;
    modal.style.top = `${newTop}px`;

    if (event.cancelable) event.preventDefault();
  }

  // 모달 드래그 종료
  function stopModalDrag() {
    _modalDragState.isDragging = false;
    document.removeEventListener("mousemove", handleModalDrag);
    document.removeEventListener("mouseup", stopModalDrag);
    document.removeEventListener("touchmove", handleModalDrag);
    document.removeEventListener("touchend", stopModalDrag);
  }

  // 모달 크기 조절 시작 (마우스 + 터치 지원)
  function startModalResize(event) {
    const modal = document.getElementById("draggable-modal");
    if (!modal || modal.classList.contains("maximized")) return;

    // 터치 이벤트 처리
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;

    _modalDragState.isResizing = true;
    _modalDragState.startX = clientX;
    _modalDragState.startY = clientY;

    const rect = modal.getBoundingClientRect();
    _modalDragState.startWidth = rect.width;
    _modalDragState.startHeight = rect.height;

    // 마우스 이벤트
    document.addEventListener("mousemove", handleModalResize);
    document.addEventListener("mouseup", stopModalResize);
    // 터치 이벤트
    document.addEventListener("touchmove", handleModalResize, {
      passive: false,
    });
    document.addEventListener("touchend", stopModalResize);

    event.preventDefault();
    event.stopPropagation();
  }

  // 모달 크기 조절 중 (마우스 + 터치 지원)
  function handleModalResize(event) {
    if (!_modalDragState.isResizing) return;

    const modal = document.getElementById("draggable-modal");
    if (!modal) return;

    // 터치 이벤트 처리
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;

    const deltaX = clientX - _modalDragState.startX;
    const deltaY = clientY - _modalDragState.startY;

    let newWidth = _modalDragState.startWidth + deltaX;
    let newHeight = _modalDragState.startHeight + deltaY;

    // 최소/최대 크기 제한
    newWidth = Math.max(320, Math.min(newWidth, window.innerWidth - 20));
    newHeight = Math.max(200, Math.min(newHeight, window.innerHeight - 20));

    modal.style.width = `${newWidth}px`;
    modal.style.height = `${newHeight}px`;

    if (event.cancelable) event.preventDefault();
  }

  // 모달 크기 조절 종료
  function stopModalResize() {
    _modalDragState.isResizing = false;
    document.removeEventListener("mousemove", handleModalResize);
    document.removeEventListener("mouseup", stopModalResize);
    document.removeEventListener("touchmove", handleModalResize);
    document.removeEventListener("touchend", stopModalResize);
  }

  // 모달 크기 토글 (일반/최대화)
  function toggleModalSize() {
    const modal = document.getElementById("draggable-modal");
    if (!modal) return;

    if (modal.classList.contains("maximized")) {
      // 원래 크기로 복원
      modal.classList.remove("maximized");
      modal.style.width = "";
      modal.style.height = "";
      // 중앙으로 재배치
      setTimeout(() => {
        const rect = modal.getBoundingClientRect();
        modal.style.left = `${(window.innerWidth - rect.width) / 2}px`;
        modal.style.top = `${(window.innerHeight - rect.height) / 2}px`;
      }, 0);
    } else {
      // 최대화
      modal.classList.add("maximized");
    }
  }

  function handleModalButton(index) {
    const action = _modalButtonActions[index];
    if (typeof action === "function") {
      action();
    } else {
      closeModal();
    }
  }

  function hideModal() {
    closeModal();
  }

  function closeModal() {
    const container = document.getElementById("modal-container");
    if (container._onClose) {
      container._onClose();
      delete container._onClose;
    }
    container.innerHTML = "";
    _modalButtonActions = [];
  }

  /* ============================================
     확인 다이얼로그 (별도 레이어로 분리 - 중첩 모달 지원)
     ============================================ */
  // 콜백을 저장할 전역 변수
  let _pendingConfirmCallback = null;
  let _pendingCancelCallback = null;

  function showConfirm(message, onConfirm, onCancel) {
    // 콜백 저장 (클로저 유지를 위해 함수 참조 저장)
    _pendingConfirmCallback = onConfirm || null;
    _pendingCancelCallback = onCancel || null;

    // 별도의 confirm 컨테이너에 렌더링 (기존 모달 유지)
    let confirmContainer = document.getElementById("confirm-container");
    if (!confirmContainer) {
      confirmContainer = document.createElement("div");
      confirmContainer.id = "confirm-container";
      document.body.appendChild(confirmContainer);
    }

    confirmContainer.innerHTML = `
      <div class="confirm-overlay" onclick="handleConfirmCancel()">
        <div class="confirm-dialog" onclick="event.stopPropagation()">
          <div class="confirm-header">
            <h4>⚠️ 확인</h4>
          </div>
          <div class="confirm-body">
            <p>${message}</p>
          </div>
          <div class="confirm-footer">
            <button class="btn btn-outline" onclick="handleConfirmCancel()">취소</button>
            <button class="btn btn-primary" onclick="handleConfirmOk()">확인</button>
          </div>
        </div>
      </div>
      <style>
        .confirm-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.6);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10001; /* 모달보다 위 */
          animation: fadeIn 0.15s ease;
        }
        .confirm-dialog {
          background: white;
          border-radius: 12px;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
          max-width: 400px;
          width: 90%;
          animation: scaleIn 0.2s ease;
        }
        .confirm-header {
          padding: 16px 20px;
          border-bottom: 1px solid var(--border);
        }
        .confirm-header h4 {
          margin: 0;
          font-size: 1.1rem;
        }
        .confirm-body {
          padding: 20px;
        }
        .confirm-body p {
          margin: 0;
          line-height: 1.6;
        }
        .confirm-footer {
          padding: 12px 20px;
          border-top: 1px solid var(--border);
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }
        @keyframes scaleIn {
          from { transform: scale(0.9); opacity: 0; }
          to { transform: scale(1); opacity: 1; }
        }
      </style>
    `;
  }

  // 확인 버튼 핸들러
  function handleConfirmOk() {
    const callback = _pendingConfirmCallback;
    _pendingConfirmCallback = null;
    _pendingCancelCallback = null;
    hideConfirm();
    if (typeof callback === "function") {
      callback();
    }
  }

  // 취소 버튼 핸들러
  function handleConfirmCancel() {
    const callback = _pendingCancelCallback;
    _pendingConfirmCallback = null;
    _pendingCancelCallback = null;
    hideConfirm();
    if (typeof callback === "function") {
      callback();
    }
  }

  // 확인 다이얼로그 숨기기
  function hideConfirm() {
    const confirmContainer = document.getElementById("confirm-container");
    if (confirmContainer) {
      confirmContainer.innerHTML = "";
    }
  }

  /* ============================================
     유틸리티 함수
     ============================================ */

  // DOM 요소 가져오기
  function $(selector) {
    return document.querySelector(selector);
  }

  function $$(selector) {
    return document.querySelectorAll(selector);
  }

  // HTML 이스케이프
  function escapeHtml(text) {
    if (!text) return "";
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // 폼 데이터 가져오기
  function getFormData(formId) {
    const form = document.getElementById(formId);
    if (!form) return {};

    const data = {};
    const inputs = form.querySelectorAll("input, textarea, select");

    inputs.forEach((input) => {
      if (input.name) {
        if (input.type === "checkbox") {
          data[input.name] = input.checked;
        } else if (input.type === "number") {
          data[input.name] = input.value ? parseInt(input.value, 10) : null;
        } else {
          data[input.name] = input.value;
        }
      }
    });

    return data;
  }

  // 입력값 검증
  function validateRequired(value, fieldName) {
    if (!value || (typeof value === "string" && !value.trim())) {
      return `${fieldName}을(를) 입력해주세요.`;
    }
    return null;
  }

  function validateNumber(value, min, max, fieldName) {
    const num = parseInt(value, 10);
    if (isNaN(num)) {
      return `${fieldName}은(는) 숫자여야 합니다.`;
    }
    if (num < min || num > max) {
      return `${fieldName}은(는) ${min}~${max} 사이여야 합니다.`;
    }
    return null;
  }

  function validatePin(value) {
    if (!value || !/^\d{6}$/.test(value)) {
      return "PIN은 숫자 6자리여야 합니다.";
    }
    return null;
  }

  // 에러 표시
  function showFieldError(inputId, message) {
    const input = document.getElementById(inputId);
    if (!input) return;

    // 기존 에러 제거
    clearFieldError(inputId);

    // 에러 스타일 적용
    input.style.borderColor = "var(--accent)";

    // 에러 메시지 추가
    const errorEl = document.createElement("div");
    errorEl.className = "form-error";
    errorEl.id = `${inputId}-error`;
    errorEl.textContent = message;
    input.parentNode.appendChild(errorEl);
  }

  function clearFieldError(inputId) {
    const input = document.getElementById(inputId);
    if (input) {
      input.style.borderColor = "";
    }

    const errorEl = document.getElementById(`${inputId}-error`);
    if (errorEl) {
      errorEl.remove();
    }
  }

  function clearAllErrors() {
    $$(".form-error").forEach((el) => el.remove());
    $$(".form-input").forEach((el) => (el.style.borderColor = ""));
  }

  // 로컬 스토리지 (세션 저장용)
  function saveSession(data) {
    try {
      sessionStorage.setItem("storyCreator_session", JSON.stringify(data));
    } catch (e) {
      console.warn("Session storage not available");
    }
  }

  function loadSession() {
    try {
      const data = sessionStorage.getItem("storyCreator_session");
      return data ? JSON.parse(data) : null;
    } catch (e) {
      return null;
    }
  }

  function clearSession() {
    try {
      // 학생 세션 클리어
      sessionStorage.removeItem("storyCreator_session");
    } catch (e) {
      console.warn("Session storage not available");
    }
  }

  /**
   * 모든 세션 클리어 (학생 + 교사)
   */
  function clearAllSessions() {
    try {
      // 학생 세션
      sessionStorage.removeItem("storyCreator_session");
      // 교사 세션
      sessionStorage.removeItem("teacherToken");
      sessionStorage.removeItem("teacherEmail");
      sessionStorage.removeItem("teacherRole");
      // AppState 초기화
      AppState.currentUser = null;
      AppState.isTeacher = false;
      AppState.teacherToken = null;
      AppState.teacherEmail = null;
    } catch (e) {
      console.warn("Session storage not available");
    }
  }

  /**
   * 교사 세션만 클리어
   */
  function clearTeacherSession() {
    try {
      sessionStorage.removeItem("teacherToken");
      sessionStorage.removeItem("teacherEmail");
      sessionStorage.removeItem("teacherRole");
      AppState.isTeacher = false;
      AppState.teacherToken = null;
      AppState.teacherEmail = null;
    } catch (e) {
      console.warn("Session storage not available");
    }
  }

  /**
   * 교사 세션 존재 여부 확인
   */
  function hasTeacherSession() {
    try {
      return !!sessionStorage.getItem("teacherToken");
    } catch (e) {
      return false;
    }
  }

  // 날짜 포맷
  function formatDate(dateString) {
    if (!dateString) return "";
    const date = new Date(dateString);
    return date.toLocaleDateString("ko-KR", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  }

  function formatDateShort(dateString) {
    if (!dateString) return "";
    const date = new Date(dateString);
    return date.toLocaleDateString("ko-KR");
  }

  // 디바운스
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // 클립보드 복사
  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      showToast("복사되었습니다!", "success");
      return true;
    } catch (err) {
      // 폴백
      const textarea = document.createElement("textarea");
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      showToast("복사되었습니다!", "success");
      return true;
    }
  }

  // QR 코드 생성
  async function generateQRCode(text, elementId, size = 200) {
    const element = document.getElementById(elementId);
    if (!element) return;

    try {
      const dataUrl = await QRCode.toDataURL(text, {
        width: size,
        margin: 2,
        color: {
          dark: "#2C3E50",
          light: "#FFFFFF",
        },
      });

      element.innerHTML = `<img src="${dataUrl}" alt="QR Code" style="max-width: 100%;">`;
    } catch (err) {
      console.error("QR 생성 실패:", err);
      element.innerHTML = '<p class="text-muted">QR 코드 생성 실패</p>';
    }
  }

  // 다운로드 함수
  function downloadFile(content, filename, type = "text/plain") {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function downloadJSON(data, filename) {
    const json = JSON.stringify(data, null, 2);
    downloadFile(json, filename, "application/json");
  }

  /* ============================================
     PIN 입력 핸들러
     ============================================ */
  function setupPinInput(containerId, onComplete) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const inputs = container.querySelectorAll(".pin-input");

    inputs.forEach((input, index) => {
      input.addEventListener("input", (e) => {
        const value = e.target.value;

        // 숫자만 허용
        if (!/^\d*$/.test(value)) {
          e.target.value = "";
          return;
        }

        // 다음 입력으로 이동
        if (value && index < inputs.length - 1) {
          inputs[index + 1].focus();
        }

        // 완료 확인
        if (index === inputs.length - 1 && value) {
          const pin = Array.from(inputs)
            .map((i) => i.value)
            .join("");
          if (pin.length === 6 && onComplete) {
            onComplete(pin);
          }
        }
      });

      input.addEventListener("keydown", (e) => {
        // 백스페이스 처리
        if (e.key === "Backspace" && !e.target.value && index > 0) {
          inputs[index - 1].focus();
        }
      });

      // 붙여넣기 처리
      input.addEventListener("paste", (e) => {
        e.preventDefault();
        const paste = (e.clipboardData || window.clipboardData).getData("text");
        const digits = paste.replace(/\D/g, "").slice(0, 6);

        digits.split("").forEach((digit, i) => {
          if (inputs[i]) {
            inputs[i].value = digit;
          }
        });

        if (digits.length === 6 && onComplete) {
          onComplete(digits);
        } else if (digits.length > 0 && inputs[Math.min(digits.length, 5)]) {
          inputs[Math.min(digits.length, 5)].focus();
        }
      });
    });

    // 첫 번째 입력에 포커스
    if (inputs[0]) {
      setTimeout(() => inputs[0].focus(), 100);
    }
  }

  function getPinValue(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return "";

    const inputs = container.querySelectorAll(".pin-input");
    return Array.from(inputs)
      .map((i) => i.value)
      .join("");
  }

  function clearPinInput(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const inputs = container.querySelectorAll(".pin-input");
    inputs.forEach((input) => (input.value = ""));
    if (inputs[0]) inputs[0].focus();
  }
</script>
